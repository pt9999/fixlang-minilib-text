module UnicodeTest;


import Minilib.Text.StringEx;
import Minilib.Text.Unicode;
import Minilib.Testing.UnitTest;

test_to_utf8_utf16_utf32_string: TestCase;
test_to_utf8_utf16_utf32_string = (
    make_test("test_to_utf8_utf16_utf32_string") $ |_|
    let str = "ã‚ã„ã†";
    let utf8: UTF8String = UTFString::make $ [ 0xe3_U8, 0x81_U8, 0x82_U8, 0xe3_U8, 0x81_U8, 0x84_U8, 0xe3_U8, 0x81_U8, 0x86_U8, ];
    let utf16: UTF16String = UTFString::make $ [ 0x3042_U16, 0x3044_U16, 0x3046_U16, ];
    let utf32: UTF32String = UTFString::make $ [ 0x3042_U32, 0x3044_U32, 0x3046_U32, ];

    assert_equal("str.to_string", str, str.to_string);;
    assert_equal("utf8.to_string", str, utf8.to_string);;
    assert_equal("utf16.to_string", str, utf16.to_string);;
    assert_equal("utf16.to_string", str, utf16.to_string);;

    assert_equal("str.to_utf8_string", utf8, str.to_utf8_string);;
    assert_equal("utf8.to_utf8_string", utf8, utf8.to_utf8_string);;
    assert_equal("utf16.to_utf8_string", utf8, utf16.to_utf8_string);;
    assert_equal("utf16.to_utf8_string", utf8, utf16.to_utf8_string);;

    assert_equal("str.to_utf16_string", utf16, str.to_utf16_string);;
    assert_equal("utf8.to_utf16_string", utf16, utf8.to_utf16_string);;
    assert_equal("utf16.to_utf16_string", utf16, utf16.to_utf16_string);;
    assert_equal("utf16.to_utf16_string", utf16, utf16.to_utf16_string);;

    assert_equal("str.to_utf32_string", utf32, str.to_utf32_string);;
    assert_equal("utf8.to_utf32_string", utf32, utf8.to_utf32_string);;
    assert_equal("utf16.to_utf32_string", utf32, utf16.to_utf32_string);;
    assert_equal("utf16.to_utf32_string", utf32, utf16.to_utf32_string);;
    pure()
);

test_utf32_string_get_size: TestCase;
test_utf32_string_get_size = (
    make_test("test_utf_string_get_size") $ |_|
    let str = "aAã‚ã„ã†ğŸ˜ŠğŸ˜€";
    let utf32: UTF32String = str.to_utf32_string;
    assert_equal("size", 7, utf32.get_size)
);

test_utf32_string_is_empty: TestCase;
test_utf32_string_is_empty = (
    make_test("test_utf32_string_is_empty") $ |_|
    let utf32: UTF32String = UTFString::empty;
    assert_equal("is_empty", true, utf32.is_empty);;
    let utf32: UTF32String = "aAã‚ã„ã†ğŸ˜ŠğŸ˜€".to_utf32_string;
    assert_equal("is_empty", false, utf32.is_empty)
);

test_utf32_string_at: TestCase;
test_utf32_string_at = (
    make_test("test_utf32_string_at") $ |_|
    let str = "aAã‚ã„ã†ğŸ˜ŠğŸ˜€";
    let utf32: UTF32String = str.to_utf32_string;
    assert_equal("at", 0x3042_U32 /* 'ã‚' */, utf32.@(2));;
    assert_equal("at", 0x1f600_U32 /* 'ğŸ˜€' */, utf32.@(6));;
    pure()
);

test_utf32_string_get_sub: TestCase;
test_utf32_string_get_sub = (
    make_test("test_utf32_string_get_sub") $ |_|
    let str = "aAã‚ã„ã†ğŸ˜ŠğŸ˜€";
    let utf32: UTF32String = str.to_utf32_string;
    assert_equal("get_sub", "ã‚ã„ã†", utf32.get_sub(2, 5).to_string);;
    assert_equal("get_sub", "ğŸ˜ŠğŸ˜€", utf32.get_sub(5, 7).to_string);;
    pure()
);

test_utf32_string_additive: TestCase;
test_utf32_string_additive = (
    make_test("test_utf32_string_additive") $ |_|
    let utf32: UTF32String = zero;
    let utf32: UTF32String = utf32 + "aAã‚".to_utf32_string;
    let utf32: UTF32String = utf32.concat("ã„ã†".to_utf32_string);
    let utf32: UTF32String = utf32 + "ğŸ˜ŠğŸ˜€".to_utf32_string;
    assert_equal("eq", "aAã‚ã„ã†ğŸ˜ŠğŸ˜€", utf32.to_string)
);

test_utf8_to_utf32_ok: (Array U8, Array U32) -> TestCase;
test_utf8_to_utf32_ok = |(a8, a32)| (
    let testname = "test_utf8_to_utf32_ok (" + a32.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf8_to_utf32(a8, Array::empty(0));
    assert_equal("eq", a32, actual);;
    pure()
);

test_utf8_to_utf32: TestCase;
test_utf8_to_utf32 = (
    [
        test_utf8_to_utf32_ok $ ([], []),
        test_utf8_to_utf32_ok $ ([0_U8, 127_U8], [0_U32, 127_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11000010 = */ 194_U8, /* 0b10000000 = */ 128_U8], [/* 0x0080 = */128_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11010011 = */ 211_U8, /* 0b10100100 = */ 164_U8], [/* 0x04E4 = */1252_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11011111 = */ 223_U8, /* 0b10111111 = */ 191_U8], [/* 0x07FF = */2047_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11100000 = */ 224_U8, /* 0b10100000 = */ 160_U8, /* 0b10000000 = */ 128_U8], [/* 0x0800 = */2048_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11101111 = */ 239_U8, /* 0b10111111 = */ 191_U8, /* 0b101111 = */ 191_U8], [/* 0xFFFF = */65535_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11110000 = */ 240_U8, /* 0b10010000 = */ 144_U8, /* 0b10000000 = */ 128_U8, /* 0b10000000 = */ 128_U8], [/* 0x10000 = */65536_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11110100 = */ 244_U8, /* 0b10001111 = */ 143_U8, /* 0b10111111 = */ 191_U8, /* 0b10111111 = */ 191_U8], [/* 0x10FFFF = */1114111_U32]),
        TestCase::empty
    ].run_tests
);

test_utf32_to_utf8_ok: (Array U32, Array U8) -> TestCase;
test_utf32_to_utf8_ok = |(a32, a8)| (
    let testname = "test_utf32_to_utf8_ok (" + a8.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf32_to_utf8(a32, Array::empty(0));
    assert_equal("eq", a8, actual);;
    pure()
);

test_utf32_to_utf8: TestCase;
test_utf32_to_utf8 = (
    [
        test_utf32_to_utf8_ok $ ([], []),
        test_utf32_to_utf8_ok $ ([0_U32, 127_U32], [0_U8, 127_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x0080 = */128_U32], [/* 0b11000010 = */ 194_U8, /* 0b10000000 = */ 128_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x04E4 = */1252_U32], [/* 0b11010011 = */ 211_U8, /* 0b10100100 = */ 164_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x07FF = */2047_U32], [/* 0b11011111 = */ 223_U8, /* 0b10111111 = */ 191_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x0800 = */2048_U32], [/* 0b11100000 = */ 224_U8, /* 0b10100000 = */ 160_U8, /* 0b10000000 = */ 128_U8]),
        test_utf32_to_utf8_ok $ ([/* 0xFFFF = */65535_U32], [/* 0b11101111 = */ 239_U8, /* 0b10111111 = */ 191_U8, /* 0b101111 = */ 191_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x10000 = */65536_U32], [/* 0b11110000 = */ 240_U8, /* 0b10010000 = */ 144_U8, /* 0b10000000 = */ 128_U8, /* 0b10000000 = */ 128_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x10FFFF = */1114111_U32], [/* 0b11110100 = */ 244_U8, /* 0b10001111 = */ 143_U8, /* 0b10111111 = */ 191_U8, /* 0b10111111 = */ 191_U8]),
        TestCase::empty
    ].run_tests
);

test_utf16_to_utf32_ok: (Array U16, Array U32) -> TestCase;
test_utf16_to_utf32_ok = |(a16, a32)| (
    let testname = "test_utf16_to_utf32_ok (" + a32.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf16_to_utf32(a16, Array::empty(0));
    assert_equal("eq", a32, actual);;
    pure()
);

test_utf16_to_utf32: TestCase;
test_utf16_to_utf32 = (
    [
        test_utf16_to_utf32_ok $ ([], []),
        test_utf16_to_utf32_ok $ ([0_U16, 65535_U16], [0_U32, 65535_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xD800 = */ 55296_U16, /* 0xDC00 = */ 56320_U16], [/* 0x10000 = */65536_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xD83D = */ 55357_U16, /* 0xDE38 = */ 56888_U16], [/* 0x1F638 = */128568_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xDBFF = */ 56319_U16, /* 0xDFFF = */ 57343_U16], [/* 0x10FFFF = */1114111_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xD800 = */ 55296_U16, /* 0xD83D = */ 55357_U16, /* 0xDE38 = */ 56888_U16], [/* 0xFFFD = */ 65533_U32, /* 0x1F638 = */128568_U32]),
        TestCase::empty
    ].run_tests
);

test_utf32_to_utf16_ok: (Array U32, Array U16) -> TestCase;
test_utf32_to_utf16_ok = |(a32, a16)| (
    let testname = "test_utf32_to_utf16_ok (" + a16.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf32_to_utf16(a32, Array::empty(0));
    assert_equal("eq", a16, actual);;
    pure()
);

test_utf32_to_utf16: TestCase;
test_utf32_to_utf16 = (
    [
        test_utf32_to_utf16_ok $ ([], []),
        test_utf32_to_utf16_ok $ ([0_U32, 65535_U32], [0_U16, 65535_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x10000 = */65536_U32], [/* 0xD800 = */ 55296_U16, /* 0xDC00 = */ 56320_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x1F638 = */128568_U32], [/* 0xD83D = */ 55357_U16, /* 0xDE38 = */ 56888_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x10FFFF = */1114111_U32], [/* 0xDBFF = */ 56319_U16, /* 0xDFFF = */ 57343_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x110000 = */1114112_U32], [/* 0xFFFD = */ 65533_U16]),
        TestCase::empty
    ].run_tests
);

test_utf8_enc_dec_ok: String -> TestCase;
test_utf8_enc_dec_ok = |str| (
    let testname = "test_utf8_enc_dec_ok (" + str + ")";
    make_test(testname) $ |_|
    let a8 = str.get_bytes.pop_back;
    let a32 = utf8_to_utf32(a8, Array::empty(0));
    let a16 = utf32_to_utf16(a32, Array::empty(0));
    let a32 = utf16_to_utf32(a16, Array::empty(0));
    let a8 = utf32_to_utf8(a32, Array::empty(0));
    let actual = a8._unsafe_to_string;
    assert_equal("eq", str, actual);;
    pure()
);

test_utf8_enc_dec: TestCase;
test_utf8_enc_dec = (
    [
        test_utf8_enc_dec_ok $ "aAã‚ã„ã†ğŸ˜ŠğŸ˜€",
        TestCase::empty
    ].run_tests
);

main: IO ();
main = (
    [
        test_to_utf8_utf16_utf32_string,
        test_utf32_string_is_empty,
        test_utf32_string_get_size,
        test_utf32_string_at,
        test_utf32_string_get_sub,
        test_utf32_string_additive,
        test_utf8_to_utf32,
        test_utf32_to_utf8,
        test_utf16_to_utf32,
        test_utf32_to_utf16,
        test_utf8_enc_dec,
        TestCase::empty
    ]
    .run_test_driver
);

