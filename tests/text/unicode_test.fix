module UnicodeTest;


import Minilib.Text.StringEx;
import Minilib.Text.Unicode;
import Minilib.Testing.UnitTest;

// test for `to_string`, `to_utf8_string`, `to_utf16_string`, `to_utf32_string`
test_to_utf8_utf16_utf32_string: TestCase;
test_to_utf8_utf16_utf32_string = (
    make_test("test_to_utf8_utf16_utf32_string") $ |_|
    let str = "„ÅÇ„ÅÑ„ÅÜ";
    let utf8: UTF8String = UTFString::make $ [ 0xe3_U8, 0x81_U8, 0x82_U8, 0xe3_U8, 0x81_U8, 0x84_U8, 0xe3_U8, 0x81_U8, 0x86_U8, ];
    let utf16: UTF16String = UTFString::make $ [ 0x3042_U16, 0x3044_U16, 0x3046_U16, ];
    let utf32: UTF32String = UTFString::make $ [ 0x3042_U32, 0x3044_U32, 0x3046_U32, ];

    assert_equal("str.to_string", str, str.to_string);;
    assert_equal("utf8.to_string", str, utf8.to_string);;
    assert_equal("utf16.to_string", str, utf16.to_string);;
    assert_equal("utf16.to_string", str, utf16.to_string);;

    assert_equal("str.to_utf8_string", utf8, str.to_utf8_string);;
    assert_equal("utf8.to_utf8_string", utf8, utf8.to_utf8_string);;
    assert_equal("utf16.to_utf8_string", utf8, utf16.to_utf8_string);;
    assert_equal("utf16.to_utf8_string", utf8, utf16.to_utf8_string);;

    assert_equal("str.to_utf16_string", utf16, str.to_utf16_string);;
    assert_equal("utf8.to_utf16_string", utf16, utf8.to_utf16_string);;
    assert_equal("utf16.to_utf16_string", utf16, utf16.to_utf16_string);;
    assert_equal("utf16.to_utf16_string", utf16, utf16.to_utf16_string);;

    assert_equal("str.to_utf32_string", utf32, str.to_utf32_string);;
    assert_equal("utf8.to_utf32_string", utf32, utf8.to_utf32_string);;
    assert_equal("utf16.to_utf32_string", utf32, utf16.to_utf32_string);;
    assert_equal("utf16.to_utf32_string", utf32, utf16.to_utf32_string);;
    pure()
);

test_utf32_string_make: TestCase;
test_utf32_string_make = (
    make_test("test_utf32_string_make") $ |_|
    let actual: UTF32String = UTFString::make([12354_U32, 12356_U32, 12358_U32]);
    let expected = "„ÅÇ„ÅÑ„ÅÜ".to_utf32_string;
    assert_equal("eq", expected, actual)
);

test_utf32_string_from_array: TestCase;
test_utf32_string_from_array = (
    make_test("test_utf32_string_from_array") $ |_|
    let actual: UTF32String = UTFString::from_array([12354_U32, 12356_U32, 12358_U32]);
    let expected = "„ÅÇ„ÅÑ„ÅÜ".to_utf32_string;
    assert_equal("eq", expected, actual)
);

test_utf32_string_to_array: TestCase;
test_utf32_string_to_array = (
    make_test("test_utf32_string_to_array") $ |_|
    let wstr = "„ÅÇ„ÅÑ„ÅÜ".to_utf32_string;
    let actual = wstr.to_array;
    let expected = [12354_U32, 12356_U32, 12358_U32];
    assert_equal("eq", expected, actual)
);

test_utf32_string_from_iter: TestCase;
test_utf32_string_from_iter = (
    make_test("test_utf32_string_from_iter") $ |_|
    let actual: UTF32String = UTFString::from_iter([12354_U32, 12356_U32, 12358_U32].to_iter);
    let expected = "„ÅÇ„ÅÑ„ÅÜ".to_utf32_string;
    assert_equal("eq", expected, actual)
);

test_utf32_string_to_iter: TestCase;
test_utf32_string_to_iter = (
    make_test("test_utf32_string_to_iter") $ |_|
    let wstr = "„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì".to_utf32_string;
    let wc_min = "„ÅÜ".to_utf32_string.@(0);
    let wc_max = "„Åç".to_utf32_string.@(0);
    let actual: UTF32String = wstr.to_iter.filter(|wc| wc_min <= wc && wc <= wc_max).from_iter;
    let expected = "„ÅÜ„Åà„Åä„Åã„Åç".to_utf32_string;
    assert_equal("eq", expected, actual)
);

test_utf32_string_from_code_unit: TestCase;
test_utf32_string_from_code_unit = (
    make_test("test_utf32_string_from_code_unit") $ |_|
    let actual: UTF32String = UTFString::from_code_unit(12354_U32);
    let expected = "„ÅÇ".to_utf32_string;
    assert_equal("eq", expected, actual)
);

test_utf32_string_empty: TestCase;
test_utf32_string_empty = (
    make_test("test_utf32_string_empty") $ |_|
    let actual: UTF32String = UTFString::empty;
    let expected = "".to_utf32_string;
    assert_equal("eq", expected, actual)
);

test_utf32_string_is_empty: TestCase;
test_utf32_string_is_empty = (
    make_test("test_utf32_string_is_empty") $ |_|
    let utf32: UTF32String = UTFString::empty;
    assert_equal("is_empty", true, utf32.is_empty);;
    let utf32: UTF32String = "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ".to_utf32_string;
    assert_equal("is_empty", false, utf32.is_empty)
);

test_utf32_string_get_size: TestCase;
test_utf32_string_get_size = (
    make_test("test_utf_string_get_size") $ |_|
    let str = "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ";
    let utf32: UTF32String = str.to_utf32_string;
    assert_equal("size", 7, utf32.get_size)
);

// test for `@`
test_utf32_string_at: TestCase;
test_utf32_string_at = (
    make_test("test_utf32_string_at") $ |_|
    let str = "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ";
    let utf32: UTF32String = str.to_utf32_string;
    assert_equal("at", 0x3042_U32 /* '„ÅÇ' */, utf32.@(2));;
    assert_equal("at", 0x1f600_U32 /* 'üòÄ' */, utf32.@(6));;
    pure()
);

test_utf32_string_get_sub: TestCase;
test_utf32_string_get_sub = (
    make_test("test_utf32_string_get_sub") $ |_|
    let str = "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ";
    let utf32: UTF32String = str.to_utf32_string;
    assert_equal("get_sub", "„ÅÇ„ÅÑ„ÅÜ", utf32.get_sub(2, 5).to_string);;
    assert_equal("get_sub", "üòäüòÄ", utf32.get_sub(5, 7).to_string);;
    pure()
);

test_utf32_string_concat: TestCase;
test_utf32_string_concat = (
    make_test("test_utf32_string_concat") $ |_|
    let a = "„ÅÇ„ÅÑ„ÅÜ".to_utf32_string;
    let b = "üòäüòÄ".to_utf32_string;
    let expected = "„ÅÇ„ÅÑ„ÅÜüòäüòÄ".to_utf32_string;
    let actual = a.concat(b);
    assert_equal("eq", expected, actual)
);

test_utf32_string_find: TestCase;
test_utf32_string_find = (
    make_table_test("test_utf32_string_find",
        [
            ("", "", 0, some(0)),
            ("", "", 1, none()),
            ("", "„ÅÇ", 0, none()),
            ("„ÅÇ", "", 0, some(0)),
            ("„ÅÇ", "", 1, some(1)),
            ("„ÅÇ", "", 2, none()),
            ("„ÅÇ", "„ÅÇ", 0, some(0)),
            ("„ÅÇ", "„ÅÇ", 1, none()),
            ("09AZaz„ÅÇ„Ç¢Êº¢üòäüòÄ", "Êº¢üòä", 0, some(8)),
            ("09AZaz„ÅÇ„Ç¢Êº¢üòäüòÄ", "Êº¢üòä", 8, some(8)),
            ("09AZaz„ÅÇ„Ç¢Êº¢üòäüòÄ", "Êº¢üòä", 9, none()),
            ("09AZaz„ÅÇ„Ç¢Êº¢üòäüòÄ", "Êº¢üòä", 100, none()),
            ("ababa", "aba", 3, none()),
        ],
        |(str, tok, start, expected)|
        let str = str.to_utf32_string;
        let tok = tok.to_utf32_string;
        let actual = str.find(tok, start);
        assert_equal("eq", expected, actual)
    )
);

test_utf32_string_push_back: TestCase;
test_utf32_string_push_back = (
    make_table_test("test_utf32_string_push_back",
        [
            ("", "„ÅÇ", "„ÅÇ"),
            ("üòäüòÄ", "üòÄ", "üòäüòÄüòÄ"),
        ],
        |(str, c, expected)|
        let str = str.to_utf32_string;
        let c = c.to_utf32_string.@(0);
        let expected = expected.to_utf32_string;
        let actual = str.push_back(c);
        assert_equal("eq", expected, actual)
    )
);

test_utf32_string_pop_back: TestCase;
test_utf32_string_pop_back = (
    make_table_test("test_utf32_string_pop_back",
        [
            ("", ""),
            ("„ÅÇ„ÅÑ„ÅÜ", "„ÅÇ„ÅÑ"),
            ("üòäüòÄüòÄ", "üòäüòÄ"),
        ],
        |(str, expected)|
        let str = str.to_utf32_string;
        let expected = expected.to_utf32_string;
        let actual = str.pop_back;
        assert_equal("eq", expected, actual)
    )
);

test_utf32_string_set: TestCase;
test_utf32_string_set = (
    make_table_test("test_utf32_string_set",
        [
            ("abcde", 2, "üòÄ", "abüòÄde"),
            ("„ÅÇ„ÅÑ„ÅÜ„Åà„Åä", 2, "üòÄ", "„ÅÇ„ÅÑüòÄ„Åà„Åä"),
        ],
        |(str, i, c, expected)|
        let str = str.to_utf32_string;
        let c = c.to_utf32_string.@(0);
        let expected = expected.to_utf32_string;
        let actual = str.set(i, c);
        assert_equal("eq", expected, actual)
    )
);

test_utf32_string_split: TestCase;
test_utf32_string_split = (
    make_table_test("test_utf32_string_split",
        [
            ("", "", []),
            ("a„ÅÇüòÄ", "", ["a", "„ÅÇ", "üòÄ"]),
            ("", "a", [""]),
            ("a", "", ["a"]),
            ("a", "b", ["a"]),
            ("a", "a", ["", ""]),
            ("ababa", "a", ["", "b", "b", ""]),
            ("ababa", "b", ["a", "a", "a"]),
            ("ababa", "aba", ["", "ba"]),
            ("ababa", "ababa", ["", ""]),
            ("ababa", "abcba", ["ababa"]),
            ("", "üòÄ", [""]),
            ("üòÄ", "", ["üòÄ"]),
            ("üòÄ", "üòä", ["üòÄ"]),
            ("üòÄ", "üòÄ", ["", ""]),
            ("„ÅÇüòÄ„ÅÇüòÄ„ÅÇ", "„ÅÇ", ["", "üòÄ", "üòÄ", ""]),
            ("„ÅÇüòÄ„ÅÇüòÄ„ÅÇ", "üòÄ", ["„ÅÇ", "„ÅÇ", "„ÅÇ"]),
            ("„ÅÇüòÄ„ÅÇüòÄ„ÅÇ", "„ÅÇüòÄ„ÅÇ", ["", "üòÄ„ÅÇ"]),
            ("„ÅÇüòÄ„ÅÇüòÄ„ÅÇ", "„ÅÇüòÄ„ÅÇüòÄ„ÅÇ", ["", ""]),
            ("„ÅÇüòÄ„ÅÇüòÄ„ÅÇ", "„ÅÇüòÄ„ÅÑüòÄ„ÅÇ", ["„ÅÇüòÄ„ÅÇüòÄ„ÅÇ"]),
            ("Â§ß„Åç„Å™„ÄÄÊ†ó„ÅÆ„ÄÄÊú®„ÅÆ„ÄÄ‰∏ã„Åß", "„ÄÄ", ["Â§ß„Åç„Å™","Ê†ó„ÅÆ","Êú®„ÅÆ","‰∏ã„Åß"]),
            ("Â§ß„Åç„Å™Ê†ó„ÅÆÊú®„ÅÆ‰∏ã„Åß", "Ê†ó„ÅÆÊú®„ÅÆ", ["Â§ß„Åç„Å™", "‰∏ã„Åß"]),
        ],
        |(str, sep, expected)|
        let str = str.to_utf32_string;
        let sep = sep.to_utf32_string;
        let arr: Array UTF32String = str.split(sep).to_array;
        let actual = arr.map(to_string);
        assert_equal("eq", expected, actual)
    )
);

test_to_wide_char: TestCase;
test_to_wide_char = (
    make_test("test_to_wide_char") $ |_|
    let str = "";
    assert_equal("str size=0", 0_U32, str.to_wide_char);;
    let str = "„ÅÇ";
    assert_equal("str size=1", 12354_U32, str.to_wide_char);;
    let str = "A";
    assert_equal("str size=1", 65_U32, str.to_wide_char);;
    let wstr: UTF8String = "„ÅÇ".to_utf8_string;
    assert_equal("utf8 size=1", 12354_U32, wstr.to_wide_char);;
    let wstr: UTF16String = "„ÅÇ".to_utf16_string;
    assert_equal("utf16 size=1", 12354_U32, wstr.to_wide_char);;
    let wstr: UTF32String = "„ÅÇ".to_utf32_string;
    assert_equal("utf32 size=1", 12354_U32, wstr.to_wide_char);;
    pure()
);

// test for `Zero`, `Add`
test_utf32_string_zero_add: TestCase;
test_utf32_string_zero_add = (
    make_test("test_utf32_string_zero_add") $ |_|
    let utf32: UTF32String = zero;
    let utf32: UTF32String = utf32 + "aA„ÅÇ".to_utf32_string;
    let utf32: UTF32String = utf32 + "„ÅÑ„ÅÜ".to_utf32_string;
    let utf32: UTF32String = utf32 + "üòäüòÄ".to_utf32_string;
    assert_equal("eq", "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", utf32.to_string)
);

test_utf32_string_eq: TestCase;
test_utf32_string_eq = (
    make_table_test("test_utf32_string_eq",
        [
            ("", "", true),
            ("", "a", false),
            ("aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", true),
            ("aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", "aA„ÅÇ„ÅÑ„ÅÜüòäüòä", false),
        ],
        |(a, b, expected)|
        let a = a.to_utf32_string;
        let b = b.to_utf32_string;
        let actual = a == b;
        assert_equal("eq", expected, actual)
    )
);

test_utf32_string_less_than: TestCase;
test_utf32_string_less_than = (
    make_table_test("test_utf32_string_less_than",
        [
            ("", "", false),
            ("", "a", true),
            ("a", "", false),
            ("„ÅÅ„ÅÉ„ÅÖ", "„ÅÇ„ÅÑ„ÅÜ", true),
            ("„ÅÇ„ÅÑ„ÅÜ", "„ÅÅ„ÅÉ„ÅÖ", false),
            ("–ê–ë–í", "„ÅÇ„ÅÑ„ÅÜ", true),
            ("üòÄ", "üòä", true),
            ("aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", "aA„ÅÇ„ÅÑ„ÅÜüòäüòä", true),
            ("aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", false),
        ],
        |(a, b, expected)|
        let a = a.to_utf32_string;
        let b = b.to_utf32_string;
        let actual = a < b;
        assert_equal("eq", expected, actual)
    )
);

test_utf32_string_less_than_or_eq: TestCase;
test_utf32_string_less_than_or_eq = (
    make_table_test("test_utf32_string_less_than_or_eq",
        [
            ("", "", true),
            ("", "a", true),
            ("a", "", false),
            ("„ÅÅ„ÅÉ„ÅÖ", "„ÅÇ„ÅÑ„ÅÜ", true),
            ("„ÅÇ„ÅÑ„ÅÜ", "„ÅÅ„ÅÉ„ÅÖ", false),
            ("–ê–ë–í", "„ÅÇ„ÅÑ„ÅÜ", true),
            ("üòÄ", "üòä", true),
            ("aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", "aA„ÅÇ„ÅÑ„ÅÜüòäüòä", true),
            ("aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ", true),
        ],
        |(a, b, expected)|
        let a = a.to_utf32_string;
        let b = b.to_utf32_string;
        let actual = a <= b;
        assert_equal("eq", expected, actual)
    )
);

//----------------------------------------------------------------------------

test_utf8_to_utf32_ok: (Array U8, Array U32) -> TestCase;
test_utf8_to_utf32_ok = |(a8, a32)| (
    let testname = "test_utf8_to_utf32_ok (" + a32.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf8_to_utf32(a8, Array::empty(0));
    assert_equal("eq", a32, actual);;
    pure()
);

test_utf8_to_utf32: TestCase;
test_utf8_to_utf32 = (
    [
        test_utf8_to_utf32_ok $ ([], []),
        test_utf8_to_utf32_ok $ ([0_U8, 127_U8], [0_U32, 127_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11000010 = */ 194_U8, /* 0b10000000 = */ 128_U8], [/* 0x0080 = */128_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11010011 = */ 211_U8, /* 0b10100100 = */ 164_U8], [/* 0x04E4 = */1252_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11011111 = */ 223_U8, /* 0b10111111 = */ 191_U8], [/* 0x07FF = */2047_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11100000 = */ 224_U8, /* 0b10100000 = */ 160_U8, /* 0b10000000 = */ 128_U8], [/* 0x0800 = */2048_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11101111 = */ 239_U8, /* 0b10111111 = */ 191_U8, /* 0b101111 = */ 191_U8], [/* 0xFFFF = */65535_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11110000 = */ 240_U8, /* 0b10010000 = */ 144_U8, /* 0b10000000 = */ 128_U8, /* 0b10000000 = */ 128_U8], [/* 0x10000 = */65536_U32]),
        test_utf8_to_utf32_ok $ ([/* 0b11110100 = */ 244_U8, /* 0b10001111 = */ 143_U8, /* 0b10111111 = */ 191_U8, /* 0b10111111 = */ 191_U8], [/* 0x10FFFF = */1114111_U32]),
        TestCase::empty
    ].run_tests
);

test_utf32_to_utf8_ok: (Array U32, Array U8) -> TestCase;
test_utf32_to_utf8_ok = |(a32, a8)| (
    let testname = "test_utf32_to_utf8_ok (" + a8.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf32_to_utf8(a32, Array::empty(0));
    assert_equal("eq", a8, actual);;
    pure()
);

test_utf32_to_utf8: TestCase;
test_utf32_to_utf8 = (
    [
        test_utf32_to_utf8_ok $ ([], []),
        test_utf32_to_utf8_ok $ ([0_U32, 127_U32], [0_U8, 127_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x0080 = */128_U32], [/* 0b11000010 = */ 194_U8, /* 0b10000000 = */ 128_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x04E4 = */1252_U32], [/* 0b11010011 = */ 211_U8, /* 0b10100100 = */ 164_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x07FF = */2047_U32], [/* 0b11011111 = */ 223_U8, /* 0b10111111 = */ 191_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x0800 = */2048_U32], [/* 0b11100000 = */ 224_U8, /* 0b10100000 = */ 160_U8, /* 0b10000000 = */ 128_U8]),
        test_utf32_to_utf8_ok $ ([/* 0xFFFF = */65535_U32], [/* 0b11101111 = */ 239_U8, /* 0b10111111 = */ 191_U8, /* 0b101111 = */ 191_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x10000 = */65536_U32], [/* 0b11110000 = */ 240_U8, /* 0b10010000 = */ 144_U8, /* 0b10000000 = */ 128_U8, /* 0b10000000 = */ 128_U8]),
        test_utf32_to_utf8_ok $ ([/* 0x10FFFF = */1114111_U32], [/* 0b11110100 = */ 244_U8, /* 0b10001111 = */ 143_U8, /* 0b10111111 = */ 191_U8, /* 0b10111111 = */ 191_U8]),
        TestCase::empty
    ].run_tests
);

test_utf16_to_utf32_ok: (Array U16, Array U32) -> TestCase;
test_utf16_to_utf32_ok = |(a16, a32)| (
    let testname = "test_utf16_to_utf32_ok (" + a32.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf16_to_utf32(a16, Array::empty(0));
    assert_equal("eq", a32, actual);;
    pure()
);

test_utf16_to_utf32: TestCase;
test_utf16_to_utf32 = (
    [
        test_utf16_to_utf32_ok $ ([], []),
        test_utf16_to_utf32_ok $ ([0_U16, 65535_U16], [0_U32, 65535_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xD800 = */ 55296_U16, /* 0xDC00 = */ 56320_U16], [/* 0x10000 = */65536_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xD83D = */ 55357_U16, /* 0xDE38 = */ 56888_U16], [/* 0x1F638 = */128568_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xDBFF = */ 56319_U16, /* 0xDFFF = */ 57343_U16], [/* 0x10FFFF = */1114111_U32]),
        test_utf16_to_utf32_ok $ ([/* 0xD800 = */ 55296_U16, /* 0xD83D = */ 55357_U16, /* 0xDE38 = */ 56888_U16], [/* 0xFFFD = */ 65533_U32, /* 0x1F638 = */128568_U32]),
        TestCase::empty
    ].run_tests
);

test_utf32_to_utf16_ok: (Array U32, Array U16) -> TestCase;
test_utf32_to_utf16_ok = |(a32, a16)| (
    let testname = "test_utf32_to_utf16_ok (" + a16.to_string + ")";
    make_test(testname) $ |_|
    let actual = utf32_to_utf16(a32, Array::empty(0));
    assert_equal("eq", a16, actual);;
    pure()
);

test_utf32_to_utf16: TestCase;
test_utf32_to_utf16 = (
    [
        test_utf32_to_utf16_ok $ ([], []),
        test_utf32_to_utf16_ok $ ([0_U32, 65535_U32], [0_U16, 65535_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x10000 = */65536_U32], [/* 0xD800 = */ 55296_U16, /* 0xDC00 = */ 56320_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x1F638 = */128568_U32], [/* 0xD83D = */ 55357_U16, /* 0xDE38 = */ 56888_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x10FFFF = */1114111_U32], [/* 0xDBFF = */ 56319_U16, /* 0xDFFF = */ 57343_U16]),
        test_utf32_to_utf16_ok $ ([/* 0x110000 = */1114112_U32], [/* 0xFFFD = */ 65533_U16]),
        TestCase::empty
    ].run_tests
);

test_utf8_enc_dec_ok: String -> TestCase;
test_utf8_enc_dec_ok = |str| (
    let testname = "test_utf8_enc_dec_ok (" + str + ")";
    make_test(testname) $ |_|
    let a8 = str.to_array;
    let a32 = utf8_to_utf32(a8, Array::empty(0));
    let a16 = utf32_to_utf16(a32, Array::empty(0));
    let a32 = utf16_to_utf32(a16, Array::empty(0));
    let a8 = utf32_to_utf8(a32, Array::empty(0));
    let actual: String = a8.from_array;
    assert_equal("eq", str, actual);;
    pure()
);

test_utf8_enc_dec: TestCase;
test_utf8_enc_dec = (
    [
        test_utf8_enc_dec_ok $ "aA„ÅÇ„ÅÑ„ÅÜüòäüòÄ",
        TestCase::empty
    ].run_tests
);

main: IO ();
main = (
    [
        test_to_utf8_utf16_utf32_string,
        test_utf32_string_make,
        test_utf32_string_from_array,
        test_utf32_string_to_array,
        test_utf32_string_from_iter,
        test_utf32_string_to_iter,
        test_utf32_string_from_code_unit,
        test_utf32_string_empty,
        test_utf32_string_is_empty,
        test_utf32_string_get_size,
        test_utf32_string_at,
        test_utf32_string_get_sub,
        test_utf32_string_concat,
        test_utf32_string_find,
        test_utf32_string_push_back,
        test_utf32_string_pop_back,
        test_utf32_string_set,
        test_utf32_string_split,
        test_to_wide_char,
        test_utf32_string_zero_add,
        test_utf32_string_eq,
        test_utf32_string_less_than,
        test_utf32_string_less_than_or_eq,
        test_utf8_to_utf32,
        test_utf32_to_utf8,
        test_utf16_to_utf32,
        test_utf32_to_utf16,
        test_utf8_enc_dec,
    ]
    .run_test_driver
);
