module SimpleParserTest;

import Character;

import Minilib.Monad.Error;
import Minilib.Text.StringEx;
import Minilib.Text.SimpleParser;
import Minilib.Testing.UnitTest;

test_stream_readall: TestCase;
test_stream_readall = (
    make_test("test_stream_readall") $ |_|
    let str = "hello\nworld\n";
    let s: Stream = *(from_result $ str.from_string);
    let s = s.set_filename("hello.txt");
    assert_equal("filename", "hello.txt", s.@filename);;
    assert_equal("line", Stream::_first_line, s.@line);;
    assert_equal("column", Stream::_first_column, s.@column);;
    assert_equal("position", Stream::_first_position, s.@position);;
    let (arr, s) = s.read_all;
    let result_str = String::_unsafe_from_c_str (arr.push_back(0_U8));
    assert_equal("array", result_str, str);;
    assert_equal("line", Stream::_first_line + 2, s.@line);;
    assert_equal("column", Stream::_first_column, s.@column);;
    assert_equal("position", Stream::_first_position + 12, s.@position);;
    pure()
);

test_stream_error: TestCase;
test_stream_error = (
    make_test("test_stream_error") $ |_|
    let str = "hello\nworld\n";
    let s: Stream = *(from_result $ str.from_string);
    let s = s.set_filename("hello.txt").set_line(1).set_column(2);
    let res: Result ErrMsg () = s.error("errormsg");
    assert_true("res is not err", res.is_err);;
    let errmsg = res.as_err;
    assert_equal("errmsg", "hello.txt line 1, column 2: errormsg", errmsg);;
    pure()
);

test_parser_run_parser: TestCase;
test_parser_run_parser = (
    make_test("test_parser_run_parser") $ |_|
    let str = "a";
    let s: Stream = Stream::make(str);
    let res = match_any_char.run_parser(s);
    assert_true("is_ok", res.is_ok);;
    let (c, s1) = res.as_ok;
    assert_equal("c", 'a', c);;
    assert_equal("pos", 1, s1.@position);;
    let res = match_char('b').run_parser(s);
    assert_true("is_err", res.is_err);;
    assert_equal("not_match", _NotMatch, res.as_err)
);

test_parser_run_parser_str: TestCase;
test_parser_run_parser_str = (
    make_test("test_parser_run_parser_str") $ |_|
    let res = match_any_char.run_parser_str("a");
    assert_true("is_ok", res.is_ok);;
    let (c, s1) = res.as_ok;
    assert_equal("c", 'a', c);;
    assert_equal("pos", 1, s1.@position);;
    let res = match_char('b').run_parser_str("a");
    assert_true("is_err", res.is_err);;
    assert_equal("not_match", _NotMatch, res.as_err)
);

test_parser_eval_parser: TestCase;
test_parser_eval_parser = (
    make_test("test_parser_eval_parser") $ |_|
    let str = "a";
    let s: Stream = Stream::make(str);
    let res = match_any_char.eval_parser(s);
    assert_equal("ok", ok $ 'a', res);;
    let res = match_char('b').eval_parser(s);
    assert_equal("err", err $ _NotMatch, res)
);

test_parser_eval_parser_str: TestCase;
test_parser_eval_parser_str = (
    make_test("test_parser_eval_parser_str") $ |_|
    let res = match_any_char.eval_parser_str("a");
    assert_equal("ok", ok $ 'a', res);;
    let res = match_char('b').eval_parser_str("a");
    assert_equal("err", err $ _NotMatch, res)
);

test_parser_error: TestCase;
test_parser_error = (
    make_test("test_parser_error") $ |_|
    let res = do {
        error("err1"): Parser String
    }.eval_parser_str("abc");
    assert_equal("res", err $ "line 1, column 1: err1", res)
);

test_parser_catch: TestCase;
test_parser_catch = (
    make_test("test_parser_catch") $ |_|
    let res = do {
        error("err1"): Parser String
    }.catch(|errmsg|
        let str = *match_str_class(is_alpha);
        pure $ "str=" + str + " errmsg=" + errmsg
    ).eval_parser_str("abc");
    assert_equal("res", ok $ "str=abc errmsg=line 1, column 1: err1", res)
);

test_parser_repeat_ok: (String, String) -> TestCase;
test_parser_repeat_ok = |(text, expected)| (
    let testname = "test_parser_repeat_ok(" + text + "," + expected + ")";
    make_test(testname) $ |_|
    let p = Parser::repeat(Parser::match_any_char.filter(|c| !c.is_space));
    let (array, next) = *(from_result $ p.run_parser_str(text));
    let actual: String = array.from_array;
    assert_equal("expect", expected, actual);;
    pure()
);

// TODO: add tests

test_parser_repeat: TestCase;
test_parser_repeat = (
    [
        test_parser_repeat_ok $ ("abc def", "abc"),
        test_parser_repeat_ok $ ("a1b2 c3", "a1b2"),
        test_parser_repeat_ok $ (" ab", "")
    ]
    .run_tests
);

test_parser_match_str_ok: (String, String) -> TestCase;
test_parser_match_str_ok = |(text, match_)| (
    let testname = "test_parser_match_str_ok(" + text + "," + match_ + ")";
    make_test(testname) $ |_|
    let p = Parser::match_str(match_);
    let (_, next) = *(from_result $ p.run_parser_str(text));
    assert_equal("column", next.@column, Stream::_first_column + match_.get_size);;
    pure()
);

test_parser_match_str_err: (String, String) -> TestCase;
test_parser_match_str_err = |(text, match_)| (
    let testname = "test_parser_match_str_err(" + text + "," + match_ + ")";
    make_test(testname) $ |_|
    let p = Parser::match_str(match_);
    let res = p.run_parser_str(text);
    assert_true("err", res.is_err);;
    pure()
);

test_parser_match_str: TestCase;
test_parser_match_str = (
    [
        test_parser_match_str_ok $ ("null123", "null"),
        test_parser_match_str_ok $ ("false123", "false"),
        test_parser_match_str_err $ ("nulxl123", "null")
    ]
    .run_tests
);

test_parser_class_ok: (Parser String, String, String) -> TestCase;
test_parser_class_ok = |(p, text, expected)| (
    let testname = "test_parser_class_ok(" + text + "," + expected + ")";
    make_test(testname) $ |_|
    let (token, next) = *(from_result $ p.run_parser_str(text));
    assert_equal("token", expected, token);;
    pure()
);

test_parser_class: TestCase;
test_parser_class = (
    [
        test_parser_class_ok $ (match_str_class_digit, "01234abc", "01234"),
        test_parser_class_ok $ (match_str_class_digit, "abc0123", ""),
        test_parser_class_ok $ (match_str_class_lower, "abc0123", "abc")
    ].run_tests
);

test_parser_integer_ok: (String, I64) -> TestCase;
test_parser_integer_ok = |(text, expected)| (
    let testname = "test_parser_integer_ok(" + text + "," + expected.to_string + ")";
    make_test(testname) $ |_|
    let p = Parser::match_integer;
    let (actual, next) = *(from_result $ p.run_parser_str(text));
    assert_equal("integer", expected, actual);;
    pure()
);

test_parser_integer_err: (String, ErrMsg) -> TestCase;
test_parser_integer_err = |(text, expected)| (
    let testname = "test_parser_integer_err(" + text + "," + expected.to_string + ")";
    make_test(testname) $ |_|
    let p = Parser::match_integer;
    let res = p.run_parser_str(text);
    assert_true("err", res.is_err);;
    assert_equal("errmsg", expected, res.as_err);;
    pure()
);

test_parser_integer: TestCase;
test_parser_integer = (
    [
        test_parser_integer_ok $ ("01234abc", 1234),
        test_parser_integer_err $ ("abc01234", _NotMatch)
    ].run_tests
);

test_parser_bind: TestCase;
test_parser_bind = (
    make_test("test_parser_bind") $ |_|
    let text = "012abc";
    let p: Parser String = do {
        let digit: String = *match_str_class_digit;
        let lower: String = *match_str_class_lower;
        pure $ digit + "/" + lower
    };
    let expected = "012/abc";
    let (actual, s) = *(from_result $ p.run_parser_str(text));
    assert_equal("res", expected, actual);;
    pure()
);

main: IO ();
main = (
    [
        test_stream_readall,
        test_stream_error,
        test_parser_run_parser,
        test_parser_run_parser_str,
        test_parser_eval_parser,
        test_parser_eval_parser_str,
        test_parser_error,
        test_parser_catch,
        test_parser_repeat,
        test_parser_match_str,
        test_parser_class,
        test_parser_integer,
        test_parser_bind,
        TestCase::empty
    ]
    .run_test_driver
);

