module WParserTest;

import Minilib.Monad.Error;
import Minilib.Text.StringEx;
import Minilib.Text.Locale;
import Minilib.Text.Unicode;
import Minilib.Text.WideChar;
import Minilib.Text.WParser;
import Minilib.Testing.UnitTest;

// Crops the error message.
// eg. `err("line 1, column 1: fatal_error")` => `err("fatal_error")`
crop_errmsg: Result ErrMsg a -> Result ErrMsg a;
crop_errmsg = |res| (
    res.mod_err(|e|
        match e.find_last_byte(':') {
            none() => e,
            some(i) => e.get_sub(i + 2, e.get_size)
        }
    )
);

test_wstream_readall: TestCase;
test_wstream_readall = (
    make_test("test_wstream_readall") $ |_|
    let str = "ã“ã‚“ã«ã¡ã¯\nä¸–ç•Œï¼\n";
    let s: WStream = *str.from_string.from_result;
    let s = s.set_filename("hello.txt");
    assert_equal("filename", "hello.txt", s.@filename);;
    assert_equal("line", WStream::_first_line, s.@line);;
    assert_equal("column", WStream::_first_column, s.@column);;
    assert_equal("position", WStream::_first_position, s.@position);;
    let (arr, s) = s.read_all;
    let result_str: UTF32String = UTFString::make(arr);
    assert_equal("array", result_str, str.to_utf32_string);;
    assert_equal("line", WStream::_first_line + 2, s.@line);;
    assert_equal("column", WStream::_first_column, s.@column);;
    assert_equal("position", WStream::_first_position + 10, s.@position);;
    pure()
);

test_wstream_read_wstring_between: TestCase;
test_wstream_read_wstring_between = (
    make_test("test_wstream_read_wstring_between") $ |_|
    let str = "ã‚ã„ã†ãˆãŠã‹ããã‘ã“";
    let s: WStream = WStream::make(str);
    let begin_stream = s.set_position(2);
    let end_stream = s.set_position(7);
    let expected = "ã†ãˆãŠã‹ã".to_utf32_string;
    let actual = begin_stream.read_wstring_between(end_stream);
    assert_equal("eq", expected, actual);;
    let actual = end_stream.read_wstring_between(begin_stream);
    assert_equal("reversed", expected, actual);;
    pure()
);

test_wstream_error: TestCase;
test_wstream_error = (
    make_test("test_wstream_error") $ |_|
    let str = "ã“ã‚“ã«ã¡ã¯\nä¸–ç•Œï¼\n";
    let s: WStream = *str.from_string.from_result;
    let s = s.set_filename("hello.txt").set_line(1).set_column(2);
    let res: Result ErrMsg () = s.error("errormsg");
    assert_true("res is not err", res.is_err);;
    let errmsg = res.as_err;
    assert_equal("errmsg", "hello.txt line 1, column 2: errormsg", errmsg);;
    pure()
);


test_wparser_run_wparser: TestCase;
test_wparser_run_wparser = (
    make_test("test_wparser_run_wparser") $ |_|
    let str = "ã‚";
    let s: WStream = WStream::make(str);
    let res = match_any_wchar.run_wparser(s);
    assert_true("is_ok", res.is_ok);;
    let (wc, s1) = res.as_ok;
    assert_equal("wc", "ã‚".to_wide_char, wc);;
    assert_equal("pos", 1, s1.@position);;
    let res = match_wchar("ã„".to_wide_char).run_wparser(s);
    assert_true("is_err", res.is_err);;
    assert_equal("not_match", _NotMatch, res.as_err)
);

test_wparser_run_wparser_str: TestCase;
test_wparser_run_wparser_str = (
    make_test("test_wparser_run_wparser_str") $ |_|
    let res = match_any_wchar.run_wparser_str("ã‚");
    assert_true("is_ok", res.is_ok);;
    let (wc, s1) = res.as_ok;
    assert_equal("wc", "ã‚".to_wide_char, wc);;
    assert_equal("pos", 1, s1.@position);;
    let res = match_wchar("ã„".to_wide_char).run_wparser_str("ã‚");
    assert_true("is_err", res.is_err);;
    assert_equal("not_match", _NotMatch, res.as_err)
);

test_wparser_eval_wparser: TestCase;
test_wparser_eval_wparser = (
    make_test("test_wparser_eval_wparser") $ |_|
    let str = "ã‚";
    let s: WStream = WStream::make(str);
    let res = match_any_wchar.eval_wparser(s);
    assert_equal("ok", ok $ "ã‚".to_wide_char, res);;
    let res = match_wchar("ã„".to_wide_char).eval_wparser(s);
    assert_equal("err", err $ _NotMatch, res)
);

test_wparser_eval_wparser_str: TestCase;
test_wparser_eval_wparser_str = (
    make_test("test_wparser_eval_wparser_str") $ |_|
    let res = match_any_wchar.eval_wparser_str("ã‚");
    assert_equal("ok", ok $ "ã‚".to_wide_char, res);;
    let res = match_wchar("ã„".to_wide_char).eval_wparser_str("ã‚");
    assert_equal("err", err $ _NotMatch, res)
);

test_wparser_error: TestCase;
test_wparser_error = (
    make_test("test_wparser_error") $ |_|
    let res = do {
        error("err1"): WParser String
    }.eval_wparser_str("ã‚ã„ã†");
    assert_equal("res", err $ "line 1, column 1: err1", res)
);

test_wparser_catch: TestCase;
test_wparser_catch = (
    make_test("test_wparser_catch") $ |_|
    let res = do {
        error("err1"): WParser String
    }.catch(|errmsg|
        let wstr = *match_wstr_class(WideChar::is_alpha);
        pure $ "wstr=" + wstr.to_string + " errmsg=" + errmsg
    ).eval_wparser_str("ã‚ã„ã†");
    assert_equal("res", ok $ "wstr=ã‚ã„ã† errmsg=line 1, column 1: err1", res)
);

test_wparser_map_result: TestCase;
test_wparser_map_result = (
    make_table_test("test_wparser_map_result",
        [
            ("abc", "err", err $ _NotMatch),
            ("abc", "inc", ok $ "b"),
        ],
        |(text, op, expected)|
        let expected = expected.map(to_utf32_string);
        let p = match_any_wchar;
        let p = p.map_result(|a|
            if op == "err" { err $ _NotMatch };
            if op == "inc" { ok $ a + 1_U32 };
            undefined("invalid op: " + op)
        );
        let res = p.eval_wparser_str(text);
        let actual = res.map(UTFString::from_code_unit);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_unit: TestCase;
test_wparser_unit = (
    make_test("test_wparser_unit", |_|
        let p = unit;
        let res = p.run_wparser_str("abc");
        assert_true("ok", res.is_ok);;
        let ((), stream) = res.as_ok;
        assert_equal("position", 0, stream.@position)
    )
);

test_wparser_get_stream: TestCase;
test_wparser_get_stream = (
    make_test("test_wparser_get_stream", |_|
        let p = do {
            let a = *match_any_wchar;
            let begin_stream = *get_stream;
            let b = *match_any_wchar;
            let c = *match_any_wchar;
            let end_stream = *get_stream;
            let d = *match_any_wchar;
            let outer = UTFString::from_array $ [a, b, c, d];
            let inner = begin_stream.read_wstring_between(end_stream);
            pure $ (outer, inner)
        };
        let res = p.run_wparser_str("ã‚ã„ã†ãˆãŠ");
        assert_true("ok", res.is_ok);;
        let ((outer, inner), stream) = res.as_ok;
        assert_equal("eq", "ã‚ã„ã†ãˆ".to_utf32_string, outer);;
        assert_equal("eq", "ã„ã†".to_utf32_string, inner);;
        assert_equal("position", 4, stream.@position)
    )
);

test_wparser_filter: TestCase;
test_wparser_filter = (
    make_table_test("test_wparser_filter",
        [
            ("ã†ãˆãŠ", "ã‚", "ãŠ", ok $ "ã†"),
            ("ã†ãˆãŠ", "ã‹", "ã“", err $ _NotMatch),
            ("ãã‘ã“", "ã‹", "ã“", ok $ "ã"),
        ],
        |(text, min_wc, max_wc, expected)|
        let min_wc = min_wc.to_utf32_string.@(0);
        let max_wc = max_wc.to_utf32_string.@(0);
        let p = match_any_wchar.filter(|wc| min_wc <= wc && wc <= max_wc);
        let res = p.eval_wparser_str(text);
        let expected = expected.map(to_utf32_string);
        let actual = res.map(UTFString::from_code_unit);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_or_else: TestCase;
test_wparser_or_else = (
    make_test("test_wparser_or_else") $ |_|
    let fatal: ErrMsg = "fatal_error";
    let p1: WParser WideChar = not_match;
    let p2: WParser WideChar = error_parser(fatal);
    let p3: WParser WideChar = match_any_wchar;
    let text = "ã‚ã„ã†";
    let run = |p| p.eval_wparser_str(text).map(UTFString::from_code_unit).crop_errmsg;
    let a = "ã‚".to_utf32_string;
    assert_equal("pattern 11", err $ _NotMatch, run $ p1.or_else(p1));;
    assert_equal("pattern 12", err $ fatal, run $ p1.or_else(p2));;
    assert_equal("pattern 13", ok $ a, run $ p1.or_else(p3));;
    assert_equal("pattern 21", err $ fatal, run $ p2.or_else(p1));;
    assert_equal("pattern 22", err $ fatal, run $ p2.or_else(p2));;
    assert_equal("pattern 23", err $ fatal, run $ p2.or_else(p3));;
    assert_equal("pattern 31", ok $ a, run $ p3.or_else(p1));;
    assert_equal("pattern 32", ok $ a, run $ p3.or_else(p2));;
    assert_equal("pattern 33", ok $ a, run $ p3.or_else(p3));;
    pure()
);

test_wparser_or_error: TestCase;
test_wparser_or_error = (
    make_test("test_wparser_or_error") $ |_|
    let fatal: ErrMsg = "fatal_error";
    let fatal2: ErrMsg = "fatal_error2";
    let p1: WParser WideChar = not_match;
    let p2: WParser WideChar = error_parser(fatal);
    let p3: WParser WideChar = match_any_wchar;
    let text = "ã‚ã„ã†";
    let run = |p| p.eval_wparser_str(text).map(UTFString::from_code_unit).crop_errmsg;
    let a = "ã‚".to_utf32_string;
    assert_equal("pattern 1", err $ fatal2, run $ p1.or_error(fatal2));;
    assert_equal("pattern 2", err $ fatal2, run $ p2.or_error(fatal2));;
    assert_equal("pattern 3", ok $ a, run $ p3.or_error(fatal2));;
    pure()
);

test_wparser_error_parser: TestCase;
test_wparser_error_parser = (
    make_test("test_wparser_error_parser") $ |_|
    let p: WParser WideChar = error_parser("fatal_error");
    assert_equal("eq", err $ "fatal_error", p.eval_wparser_str("ã‚ã„ã†").crop_errmsg)
);

test_wparser_not_match: TestCase;
test_wparser_not_match = (
    make_test("test_wparser_not_match") $ |_|
    let p: WParser WideChar = not_match;
    assert_equal("eq", err $ _NotMatch, p.eval_wparser_str("ã‚ã„ã†").crop_errmsg)
);

test_wparser_repeat: TestCase;
test_wparser_repeat = (
    make_table_test("test_wparser_repeat",
        [
            ("", ok $ ""),
            ("a", ok $ "a"),
            ("aa", ok $ "aa"),
            ("aa ", ok $ "aa"),
            ("aa bb ã‚ã„ã†", ok $ "aa"),
            ("ã‚ã„ã†ã€€ã‹ãã", ok $ "ã‚ã„ã†"),
            ("ã‚ï¼‘ã„ï¼’ã€€ã†ï¼“", ok $ "ã‚ï¼‘ã„ï¼’"),
            ("ã€€ã‚ã„", ok $ ""),
        ],
        |(text, expected)|
        let expected = expected.map(to_utf32_string);
        let p = match_wchar_class(|c| !c.is_space).repeat.map(UTFString::from_array);
        let actual = p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_zero_or_more: TestCase;
test_wparser_zero_or_more = (
    make_table_test("test_wparser_zero_or_more",
        [
            ("", ok $ ""),
            ("a", ok $ "a"),
            ("abcde", ok $ "abcde"),
        ],
        |(text, expected)|
        let expected = expected.map(to_utf32_string);
        let p = match_any_wchar.zero_or_more.map(UTFString::from_array);
        let actual= p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_one_or_more: TestCase;
test_wparser_one_or_more = (
    make_table_test("test_wparser_one_or_more",
        [
            ("", err $ _NotMatch),
            ("a", ok $ "a"),
            ("abcde", ok $ "abcde"),
        ],
        |(text, expected)|
        let expected = expected.map(to_utf32_string);
        let p = match_any_wchar.one_or_more.map(UTFString::from_array);
        let actual = p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_if_exists: TestCase;
test_wparser_if_exists = (
    make_table_test("test_wparser_if_exists",
        [
            ("", ok $ none()),
            ("a", ok $ some $ "a"),
            ("abcde", ok $ some $ "a"),
        ],
        |(text, expected)|
        let expected = expected.map(map(to_utf32_string));
        let p = match_any_wchar.if_exists.map(map(UTFString::from_code_unit));
        let actual = p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_match_end_of_stream: TestCase;
test_wparser_match_end_of_stream = (
    make_table_test("test_wparser_match_end_of_stream",
        [
            ("", ok()),
            ("a", err $ "Missing EOS"),
        ],
        |(text, expected)|
        let p = match_end_of_stream;
        let actual = p.eval_wparser_str(text).crop_errmsg;
        assert_equal("eq", expected, actual)
    )
);

test_wparser_match_any_wchar: TestCase;
test_wparser_match_any_wchar = (
    make_table_test("test_wparser_match_any_wchar",
        [
            ("", err $ _NotMatch),
            ("abc", ok $ "a"),
            ("ã‚ã„ã†", ok $ "ã‚"),
            ("ğŸ˜ŠğŸ˜€", ok $ "ğŸ˜Š"),
        ],
        |(text, expected)|
        let expected = expected.map(to_utf32_string);
        let p = match_any_wchar.map(UTFString::from_code_unit);
        let actual = p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_match_wchar: TestCase;
test_wparser_match_wchar = (
    make_table_test("test_wparser_match_wchar",
        [
            ("", "a", err $ _NotMatch),
            ("", "ã‚", err $ _NotMatch),
            ("abc", "a", ok()),
            ("abc", "ã‚", err $ _NotMatch),
            ("ã‚ã„ã†", "a", err $ _NotMatch),
            ("ã‚ã„ã†", "ã‚", ok()),
            ("ğŸ˜ŠğŸ˜€", "a", err $ _NotMatch),
            ("ğŸ˜ŠğŸ˜€", "ã‚", err $ _NotMatch),
            ("ğŸ˜ŠğŸ˜€", "ğŸ˜Š", ok()),
        ],
        |(text, wchar, expected)|
        let wchar = wchar.to_utf32_string.@(0);
        let p = match_wchar(wchar);
        let actual = p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_match_one_of_wchar: TestCase;
test_wparser_match_one_of_wchar = (
    make_table_test("test_wparser_match_one_of_wchar",
        [
            ("", "", err $ _NotMatch),
            ("", "aã‚ğŸ˜Š", err $ _NotMatch),
            ("a", "", err $ _NotMatch),
            ("a", "a", ok $ "a"),
            ("a", "aã‚ğŸ˜Š", ok $ "a"),
            ("abcã‚ğŸ˜Š", "aã‚ğŸ˜Š", ok $ "a"),
            ("bcã‚ğŸ˜Š", "aã‚ğŸ˜Š", err $ _NotMatch),
            ("ã‚ã„ã†", "aã‚ğŸ˜Š", ok $ "ã‚"),
            ("ğŸ˜ŠğŸ˜€aã‚", "aã‚ğŸ˜Š", ok $ "ğŸ˜Š"),
        ],
        |(text, wchars, expected)|
        let expected = expected.map(to_utf32_string);
        let p = match_one_of_wchar(wchars);
        let actual = p.eval_wparser_str(text);
        assert_equal("eq", expected, actual)
    )
);

test_wparser_match_wstr: TestCase;
test_wparser_match_wstr = (
    make_table_test("test_wparser_match_wstr",
        [
            ("null123", "null", ok()),
            ("false123", "false", ok()),
            ("ã‚ã„ã†ãˆãŠ123", "ã‚ã„ã†", ok()),
            ("nulxl123", "null", err $ _NotMatch),
            ("ã‚ã„ãˆãŠ123", "ã‚ã„ã†", err $ _NotMatch),
        ],
        |(text, str, expected)|
        let p = WParser::match_wstr(str);
        let res = p.run_wparser_str(text);
        match res {
            err(e) => assert_equal("err", expected, err(e)),
            ok(((), stream)) => (
                assert_equal("ok", expected, ok());;
                assert_equal("column", stream.@column, WStream::_first_column + str.to_utf32_string.get_size)
            )
        }
    )
);

test_wparser_match_wstr_class: TestCase;
test_wparser_match_wstr_class = (
    make_table_test("test_wparser_match_wstr_class",
        [
            ("digit", "    abc", ""),
            ("digit", "0123abc", "0123"),
            ("digit", "ï¼ï¼‘ï¼’ï¼“ï½ï½‚ï½ƒ", ""),    // "ï¼ï¼‘ï¼’ï¼“" is not digits
            ("digit", "abc0123", ""),
            ("digit", "ï½ï½‚ï½ƒï¼ï¼‘ï¼’ï¼“", ""),
            ("lower", "    abc", ""),
            ("lower", "0123abc", ""),
            ("lower", "ï¼ï¼‘ï¼’ï¼“ï½ï½‚ï½ƒ", ""),
            ("lower", "abc0123", "abc"),
            ("lower", "Î±Î²Î³0123", "Î±Î²Î³"),
            ("lower", "ï½ï½‚ï½ƒï¼ï¼‘ï¼’ï¼“", "ï½ï½‚ï½ƒ"),
            ("space", "    abc", "    "),
            ("space", "0123abc", ""),
            ("space", "abc0123", ""),
        ],
        |(class_name, text, expected)|
        let p = if class_name == "digit" { match_wstr_class(WideChar::is_digit) }
        else if class_name == "lower" { match_wstr_class(WideChar::is_lower) }
        else if class_name == "space" { match_wstr_class(WideChar::is_space) }
        else { undefined("invalid class_name: " + class_name) };
        let (wstr, next) = *p.run_wparser_str(text).from_result;
        assert_equal("eq", expected.to_utf32_string, wstr)
    )
);

test_wparser_integer: TestCase;
test_wparser_integer = (
    make_table_test("test_wparser_integer",
        [
            ("", err $ _NotMatch),
            ("0", ok $ 0),
            ("1", ok $ 1),
            ("-1", err $ _NotMatch),    // currently negative integers are not supported
            ("ï¼‘", err $ _NotMatch),
            ("01234abc", ok $ 1234),
            ("012ï¼“ï¼”ï½ï½‚ï½ƒ", ok $ 12),
            ("abc01234", err $ _NotMatch),
        ],
        |(text, expected)|
        let p = WParser::match_integer;
        let res = p.run_wparser_str(text).map(|(i64, next)| i64);
        assert_equal("eq", expected, res)
    )
);

test_wparser_bind: TestCase;
test_wparser_bind = (
    make_test("test_wparser_bind") $ |_|
    let text = "012abc";
    let p: WParser UTF32String = do {
        let digit: UTF32String = *match_wstr_class(WideChar::is_digit);
        let lower: UTF32String = *match_wstr_class(WideChar::is_lower);
        pure $ digit + "/".to_utf32_string + lower
    };
    let expected = "012/abc".to_utf32_string;
    let (actual, s) = *p.run_wparser_str(text).from_result;
    assert_equal("eq", expected, actual)
);

main: IO ();
main = (
    [
        test_wstream_readall,
        test_wstream_read_wstring_between,
        test_wstream_error,
        test_wparser_run_wparser,
        test_wparser_run_wparser_str,
        test_wparser_eval_wparser,
        test_wparser_eval_wparser_str,
        test_wparser_error,
        test_wparser_catch,
        test_wparser_map_result,
        test_wparser_unit,
        test_wparser_get_stream,
        test_wparser_filter,
        test_wparser_or_else,
        test_wparser_or_error,
        test_wparser_error_parser,
        test_wparser_not_match,
        test_wparser_repeat,
        test_wparser_zero_or_more,
        test_wparser_one_or_more,
        test_wparser_if_exists,
        test_wparser_match_end_of_stream,
        test_wparser_match_any_wchar,
        test_wparser_match_one_of_wchar,
        test_wparser_match_wchar,
        test_wparser_match_wstr,
        test_wparser_match_wstr_class,
        test_wparser_integer,
        test_wparser_bind,
        TestCase::empty
    ]
    // run all tests with LC_ALL=C.UTF-8
    .map(map(with_locale(lc_all, locale_C_UTF8)))
    .run_test_driver
);

