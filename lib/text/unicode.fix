// Unicode strings and conversions (UTF8/UTF16/UTF32)
//
// An utf-8 encoded `Std::String` can be converted to `UTF8String`, `UTF16String`, `UTF32String`
// by using `to_utf8_string`, `to_utf16_string`, `to_utf32_string`.
//
// `UTF8String`, `UTF16String`, `UTF32String` can be converted to an utf-8 encoded `Std::String`
// by using `to_string`.
//
// `UTF32String` is suitable for working with strings containing Unicode characters.
//
// Example:
// ```
// let str = "aAã‚ã„ã†ðŸ˜ŠðŸ˜€";                       // an ordinary string (encoded in utf-8)
// let wstr: UTF32String = str.to_utf32_string;     // convert to a wide string
// assert_equal("size", 7, wstr.get_size);;         // number of wide characters
// let wstr = wstr.get_sub(5, 7);                   // get substring of a wide string
// assert_equal("str", "ðŸ˜ŠðŸ˜€", wstr.to_string);;   // convert back to an ordinary string
// ```
module Minilib.Text.Unicode;

import Minilib.Text.StringEx;

// Unicode string type.
//
// A unicode string is represented as an array of code units.
//
// NOTE: The array of code units NEED NOT to be null-terminated.
type UTFString a = unbox struct {
    data: Array a
};

// A unicode string which is encoded in UTF8.
type UTF8String = UTFString U8;
// A unicode string which is encoded in UTF16.
type UTF16String = UTFString U16;
// A unicode string which is encoded in UTF32.
type UTF32String = UTFString U32;

namespace UTFString {
    // Creates a unicode string from an array of code units.
    //
    // NOTE: The array of code units NEED NOT to be null-terminated.
    //
    // # Parameters
    //
    // * `array` - An array of code units.
    make: Array a -> UTFString a;
    make = |array| UTFString { data: array };

    // Converts an array of code units to a unicode string.
    //
    // `UTFString::from_array(array)` is equal to `UTFString::make(array)`.
    //
    // NOTE: The array of code units NEED NOT to be null-terminated.
    //
    // # Parameters
    //
    // * `array` - An array of code units.
    from_array: Array a -> UTFString a;
    from_array = UTFString::make;

    // Converts a unicode string to an array of code units.
    //
    // `UTFString::to_array(str)` is equal to `str.@data`.
    //
    // # Parameters
    //
    // * `str` - A unicode string.
    to_array: UTFString a -> Array a;
    to_array = UTFString::@data;

    // Creates a unicode string from a single code unit.
    //
    // # Parameters
    //
    // * `c` - A code unit.
    from_code_unit: a -> UTFString a;
    from_code_unit = |c| UTFString::make([c]);

    // An empty unicode string.
    empty: UTFString a;
    empty = UTFString { data: [] };

    // Returns if the unicode string is empty or not.
    //
    // # Parameters
    //
    // * `str` - The unicode string to be checked.
    is_empty : UTFString a -> Bool;
    is_empty = |s| s.get_size == 0;

    // Gets the length of a unicode string (= the count of code units).
    //
    // # Parameters
    //
    // * `str` - The unicode string to be converted.
    get_size: UTFString a -> I64;
    get_size = |s| s.@data.get_size;

    // Gets the code unit of a unicode string at the specified index.
    //
    // # Parameters
    //
    // * `i` - The index of the code unit.
    // * `str` - The unicode string to be converted.
    @: I64 -> UTFString a -> a;
    @ = |i, s| s.@data.@(i);

    // Returns a substring of the specified range.
    //
    // # Parameters
    //
    // * `start` - The start index of the substring.
    // * `end` - The end index of the substring.
    // * `str` - The unicode string to be sliced.
    get_sub: I64 -> I64 -> UTFString a -> UTFString a;
    get_sub = |start, end, s| UTFString { data: s.@data.get_sub(start, end) };

    // Concatenate two unicode strings.
    //
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    //
    // # Parameters
    //
    // * `first` - The first unicode string.
    // * `second` - The second unicode string.
    concat : UTFString a -> UTFString a -> UTFString a;
    concat = |rhs, lhs| (
        UTFString { data : lhs.@data.append(rhs.@data) }
    );

    // `str.find(token, start_idx)` finds the index where `token` firstly appears in `str` starting from `start_idx`.
    //
    // # Parameters
    //
    // * `token` - The token to be searched.
    // * `start_idx` - The index to start searching from.
    // * `str` - The unicode string to be searched.
    find : [a: Eq] UTFString a -> I64 -> UTFString a -> Option I64;
    find = |tok, start, str| (
        let n = str.get_size;
        let m = tok.get_size;
        let str = str.@data;
        let tok = tok.@data;
        loop(
            start, |i|
            if i >= n { break $ none() };
            let res = loop(
                0, |j|
                if j >= m { break $ true };
                if str.@(i+j) != tok.@(j) { break $ false };
                continue $ j + 1
            );
            if res { break $ some(i) };
            continue $ i + 1
        )
    );

    // Pushes a code unit to the back of a unicode string.
    //
    // # Parameters
    //
    // * `c` - The code unit.
    // * `str` - The unicode string to be modified.
    push_back: a -> UTFString a -> UTFString a;
    push_back = |c, s| s.mod_data(push_back(c));

    // Pops a code unit at the back of a unicode string.
    // If the unicode string is empty, this function does nothing.
    //
    // # Parameters
    //
    // * `str` - The unicode string to be modified.
    pop_back: UTFString a -> UTFString a;
    pop_back = |s| s.mod_data(pop_back);

    // Sets the code unit of a unicode string at the specified index.
    //
    // # Parameters
    //
    // * `i` - The index of the code unit.
    // * `c` - The code unit.
    // * `str` - The unicode string to be modified.
    set: I64 -> a -> UTFString a -> UTFString a;
    set = |i, c, s| s.mod_data(set(i, c));
}

// An empty unicode string.
impl UTFString a : Zero {
    zero = empty;
}

// Concatenates two unicode strings.
impl UTFString a: Add {
    add = |lhs, rhs| lhs.concat(rhs);
}

// Compare two unicode strings as an array of code units.
impl [a: Eq] UTFString a: Eq {
    eq = |x, y| x.@data == y.@data;
}

// Compare two unicode strings as an array of code units.
// NOTE: This is NOT affected by the `LC_COLLATE` locale, since the order of code units is not affected by the collation.
impl [a:Eq, a: LessThan] UTFString a: LessThan {
    less_than = |x, y| x.@data < y.@data;
}

// Compare two unicode strings as an array of code units.
// NOTE: This is NOT affected by the `LC_COLLATE` locale, since the order of code units is not affected by the collation.
impl [a:Eq, a: LessThanOrEq] UTFString a: LessThanOrEq {
    less_than_or_eq = |x, y| x.@data <= y.@data;
}

// TODO: add impl FromBytes, ToBytes -- requires minilib-binary
// TODO: add impl Hash               -- requires hash

impl UTFString U8: ToString {
    to_string = |s| s.@data.push_back(0_U8).from_bytes.as_ok;
}

impl UTFString U16: ToString {
    to_string = |s| s.to_utf8_string.to_string;
}

impl UTFString U32: ToString {
    to_string = |s| s.to_utf8_string.to_string;
}

trait a: ToUTF8String {
    to_utf8_string: a -> UTF8String;
}

impl String: ToUTF8String {
    to_utf8_string = |s| UTFString { data: s.to_array };
}

impl UTFString U8: ToUTF8String {
    to_utf8_string = |s| s;
}

impl UTFString U16: ToUTF8String {
    to_utf8_string = |s| s.to_utf32_string.to_utf8_string;
}

impl UTFString U32: ToUTF8String {
    to_utf8_string = |s| make $ utf32_to_utf8(s.@data, []);
}

trait a: ToUTF16String {
    to_utf16_string: a -> UTF16String;
}

impl String: ToUTF16String {
    to_utf16_string = |s| s.to_utf8_string.to_utf16_string;
}

impl UTFString U8: ToUTF16String {
    to_utf16_string = |s| s.to_utf32_string.to_utf16_string;
}

impl UTFString U16: ToUTF16String {
    to_utf16_string = |s| s;
}

impl UTFString U32: ToUTF16String {
    to_utf16_string = |s| make $ utf32_to_utf16(s.@data, []);
}

trait a: ToUTF32String {
    to_utf32_string: a -> UTF32String;
}

impl String: ToUTF32String {
    to_utf32_string = |s| s.to_utf8_string.to_utf32_string;
}

impl UTFString U8: ToUTF32String {
    to_utf32_string = |s| make $ utf8_to_utf32(s.@data, []);
}

impl UTFString U16: ToUTF32String {
    to_utf32_string = |s| make $ utf16_to_utf32(s.@data, []);
}

impl UTFString U32: ToUTF32String {
    to_utf32_string = |s| s;
}

impl UTFString U8: FromString {
    from_string = |s| ok $ s.to_utf8_string;
}

impl UTFString U16: FromString {
    from_string = |s| ok $ s.to_utf16_string;
}

impl UTFString U32: FromString {
    from_string = |s| ok $ s.to_utf32_string;
}

// ----------------------------------------------------------------------------
// Utility functions
// ----------------------------------------------------------------------------

// Convert UTF8 string to UTF32 string. Please specify the output destination buffer.
utf8_to_utf32: Array U8 -> Array U32 -> Array U32;
utf8_to_utf32 = |input, output| (
    loop(
        (output, 0, 0, 0_U32), |(output, i, n, u32)|
        if i >= input.get_size {
            // FIXME: add replacement character if n != 0
            break $ output
        };
        let u8 = input.@(i);
        //eval debug_eprintln("u8=" + u8.to_string + " n="+n.to_string+ " u32="+u32.to_string);
        if u8.bit_and(128_U8) == 0_U8 { // 0xxxxxxx
            let output = output.push_back(u8.to_U32);
            continue $ (output, i + 1, 0, 0_U32)
        };
        if u8.bit_and(64_U8) == 0_U8 {  // 10xxxxxx, Byte2 .. Byte4
            // FIXME: add replacement character if n == 0
            let u32 = u32.shift_left(6_U32).bit_or(u8.bit_and(63_U8).to_U32);
            if n <= 1 {
                let output = output.push_back(u32);
                continue $ (output, i + 1, 0, 0_U32)
            };
            continue $ (output, i + 1, n - 1, u32)
        };
        if u8.bit_and(32_U8) == 0_U8 {  // 110xxxxx, Byte 1 of 2-byte char
            let u32 = u8.bit_and(31_U8).to_U32;
            continue $ (output, i + 1, 1, u32)
        };
        if u8.bit_and(16_U8) == 0_U8 {  // 1110xxxx, Byte 1 of 3-byte char
            let u32 = u8.bit_and(15_U8).to_U32;
            continue $ (output, i + 1, 2, u32)
        };
        if u8.bit_and(8_U8) == 0_U8 {  // 11110xxx, Byte 1 of 4-byte char
            let u32 = u8.bit_and(7_U8).to_U32;
            continue $ (output, i + 1, 3, u32)
        };
        // 11111xxx, invalid code
        continue $ (output, i + 1, 0, 0_U32)
    )
);

// Encode a unicode code point to UTF-8
encode_code_point_to_utf8: U32 -> Array U8 -> Array U8;
encode_code_point_to_utf8 = |code_point, buf| (
    let code_point = (
        if 0_U32 <= code_point && code_point <= /* U+10FFFF =*/ 1114111_U32 {
            code_point
        } else {
            // code point out of range: replace to the replacement character ('ï¿½')
            /* 0xFFFD = */ 65533_U32
        }
    );

    if code_point <= 127_U32 {    // U+0000 .. U+007F
        buf
        .push_back(code_point.to_U8)
    };
    if code_point <= 2047_U32 {    // U+0080 .. U+07FF
        buf
        .push_back(192_U8.bit_or(code_point.shift_right(6_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.bit_and(63_U32).to_U8))
    };
    if code_point <= 65535_U32 {    // U+0800 .. U+FFFF
        buf
        .push_back(224_U8.bit_or(code_point.shift_right(12_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.shift_right(6_U32).bit_and(63_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.bit_and(63_U32).to_U8))
    };
    if code_point <= 1114111_U32 {  // U+10000 .. U+10FFFF
        buf
        .push_back(240_U8.bit_or(code_point.shift_right(18_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.shift_right(12_U32).bit_and(63_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.shift_right(6_U32).bit_and(63_U32).to_U8))
        .push_back(128_U8.bit_or(code_point.bit_and(63_U32).to_U8))
    };
    // not reach here
    buf
);

// Convert UTF32 string to UTF8 string. Please specify the output destination buffer.
utf32_to_utf8: Array U32 -> Array U8 -> Array U8;
utf32_to_utf8 = |input, output| (
    loop(
        (output, 0), |(output, i)|
        if i >= input.get_size {
            break $ output
        };
        let output = encode_code_point_to_utf8(input.@(i), output);
        continue $ (output, i + 1)
    )
);

// Convert UTF16 string to UTF32 string.
utf16_to_utf32: Array U16 -> Array U32 -> Array U32;
utf16_to_utf32 = |input, output| (
    loop(
        (output, 0, 0_U16), |(output, i, surrogate_1st)|
        if i >= input.get_size {
            break $ output
        };
        let u16 = input.@(i);
        if (/* 0xDC00 = */ 56320_U16 <= u16 && u16 <= 57343_U16 /* = 0xDFFF */) {
            if surrogate_1st == 0_U16 {
                // Decode error: add the replacement character ('ï¿½')
                let output = output.push_back(/* 0xFFFD = */ 65533_U32);
                continue $ (output, i + 1, 0_U16)
            };
            let surrogate_2nd = u16;
            let w = surrogate_1st.shift_right(6_U16).bit_and(15_U16).to_U32;
            let y = surrogate_1st.bit_and(63_U16).to_U32;
            let x = surrogate_2nd.bit_and(/* 0x03FF= */ 1023_U16).to_U32;
            let u32 = (w + 1_U32).shift_left(16_U32)
                    .bit_or(y.shift_left(10_U32))
                    .bit_or(x);
            let output = output.push_back(u32);
            continue $ (output, i + 1, 0_U16)
        };
        let output = if surrogate_1st != 0_U16 {
            // Decode error: add the replacement character ('ï¿½')
            output.push_back(/* 0xFFFD = */ 65533_U32)
        } else {
            output
        };
        if (/* 0xD800 = */ 55296_U16 <= u16 && u16 <= 56319_U16 /* = 0xDBFF */) {
            let surrogate_1st = u16;
            continue $ (output, i + 1, surrogate_1st)
        };
        let output = output.push_back(u16.to_U32);
        continue $ (output, i + 1, 0_U16)
    )
);

// Convert UTF32 string to UTF16 string.
utf32_to_utf16: Array U32 -> Array U16 -> Array U16;
utf32_to_utf16 = |input, output| (
    loop(
        (output, 0), |(output, i)|
        if i >= input.get_size {
            break $ output
        };
        let u32 = input.@(i);
        if u32 <= 65535_U32 {    // U+0000 .. U+FFFF
            let output = output.push_back(u32.to_U16);
            continue $ (output, i + 1)
        };
        if u32 <= 1114111_U32 {  // U+10000 .. U+10FFFF
            let u = u32.shift_right(16_U32).to_U16;
            let y = u32.shift_right(10_U32).bit_and(63_U32).to_U16;
            let x = u32.bit_and(1023_U32).to_U16;
            let output = output.push_back( // surrogate 1st
                /* 0xD800 = */ 55296_U16
                .bit_or((u-1_U16).shift_left(6_U16))
                .bit_or(y));
            let output = output.push_back(  // surrogate 2nd
                /* 0xDC00 = */ 56320_U16
                .bit_or(x));
            continue $ (output, i + 1)
        };
        // code point is out of range: add the replacement character ('ï¿½')
        let output = output.push_back(/* 0xFFFD = */ 65533_U16);
        continue $ (output, i + 1)
    )
);
